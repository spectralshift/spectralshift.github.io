{"version":3,"file":"static/js/165.0d79daa1.chunk.js","mappings":"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","sources":["components/PageHeader.js","components/TooltipTextField.js","pages/cividle/IdleEraTime.js","utils/cividlehelpers.js"],"sourcesContent":["// src/components/PageHeader.js\r\nimport React from 'react';\r\nimport { Typography, Box } from '@mui/material';\r\n\r\nconst PageHeader = ({ title, description }) => {\r\n  return (\r\n    <Box sx={{ mb: 4 }}>\r\n      <Typography variant=\"h4\" gutterBottom>\r\n        {title}\r\n      </Typography>\r\n      {description && (\r\n        <Typography \r\n          variant=\"subtitle1\" \r\n          sx={{ \r\n            mb: 3, \r\n            fontStyle: 'italic',\r\n            color: 'text.secondary',\r\n            borderLeft: '4px solid',\r\n            borderColor: 'primary.main',\r\n            pl: 2\r\n          }}\r\n        >\r\n          {description}\r\n        </Typography>\r\n      )}\r\n    </Box>\r\n  );\r\n};\r\n\r\nexport default PageHeader;","import React from 'react';\r\nimport { TextField, Tooltip, IconButton } from '@mui/material';\r\nimport HelpOutlineIcon from '@mui/icons-material/HelpOutline';\r\n\r\nconst TooltipTextField = ({ tooltip, ...props }) => {\r\n  return (\r\n    <div style={{ display: 'flex', alignItems: 'center' }}>\r\n      <TextField {...props} />\r\n      <Tooltip title={tooltip} arrow placement=\"top\">\r\n        <IconButton size=\"small\" style={{ marginLeft: '8px' }}>\r\n          <HelpOutlineIcon fontSize=\"small\" />\r\n        </IconButton>\r\n      </Tooltip>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default TooltipTextField;","import React, { useState, useEffect } from 'react';\r\nimport { TextField, Typography, Paper, Box, Table, TableBody, TableCell, TableContainer, TableHead, TableRow, Grid } from '@mui/material';\r\nimport { getEraData } from '../../utils/cividlehelpers';\r\nimport PageHeader from '../../components/PageHeader';\r\nimport TooltipTextField from '../../components/TooltipTextField';\r\n\r\nconst PAGE_TITLE = \"Idle to Era Calculator\";\r\nconst PAGE_DESCRIPTION = \"This calculates the amount of time it takes to get to each Era based on your starting science.\"\r\n\r\n\r\n\r\n\r\nconst IdleEraTime = () => {\r\n  const [sciencePerSec, setSciencePerSec] = useState('');\r\n  const [eraData, setEraData] = useState([]);\r\n\r\n  useEffect(() => {\r\n    if (sciencePerSec && !isNaN(parseFloat(sciencePerSec))) {\r\n      const data = getEraData(parseFloat(sciencePerSec));\r\n      setEraData(data);\r\n    } else {\r\n      setEraData([]);\r\n    }\r\n  }, [sciencePerSec]);\r\n\r\n  return (\r\n    <Paper elevation={3} sx={{ p: 3, maxWidth: 800, mx: 'auto' }}>\r\n      <PageHeader title={PAGE_TITLE} description={PAGE_DESCRIPTION} />\r\n      <Box sx={{ mb: 3, bgcolor: 'background.paper', p: 2, borderRadius: 1 }}>\r\n          <Grid item xs={12} sm={8}>\r\n            <TooltipTextField\r\n\t\t\ttooltip=\"Enter the amount of science you have on rebirth.\"\r\n          label=\"Science/sec\"\r\n          type=\"number\"\r\n          value={sciencePerSec}\r\n          onChange={(e) => setSciencePerSec(e.target.value)}\r\n          variant=\"outlined\"\r\n          fullWidth\r\n          inputProps={{ step: 'any' }}\r\n            />\r\n          </Grid>\r\n      </Box>\r\n      {eraData.length > 0 && (\r\n        <TableContainer component={Paper}>\r\n          <Table>\r\n            <TableHead>\r\n              <TableRow>\r\n                <TableCell>Era</TableCell>\r\n                <TableCell>Era Title</TableCell>\r\n                <TableCell>Era Cost</TableCell>\r\n                <TableCell>Time to Reach</TableCell>\r\n              </TableRow>\r\n            </TableHead>\r\n            <TableBody>\r\n              {eraData.map((row) => (\r\n                <TableRow key={row.Era}>\r\n                  <TableCell>{row.Era}</TableCell>\r\n                  <TableCell>{row.EraTitle}</TableCell>\r\n                  <TableCell>{row.EraCost}</TableCell>\r\n                  <TableCell>{row.TimeToReach}</TableCell>\r\n                </TableRow>\r\n              ))}\r\n            </TableBody>\r\n          </Table>\r\n        </TableContainer>\r\n      )}\r\n    </Paper>\r\n  );\r\n};\r\n\r\nexport default IdleEraTime;","import eraData from '../data/eraData.json';\r\n\r\nexport const convertInputUsingLetterUnitToNumber = (value, unit) => {\r\n  const unitMultipliers = {\r\n    'K': 1e3,\r\n    'M': 1e6,\r\n    'B': 1e9,\r\n    'T': 1e12,\r\n    'Q': 1e15\r\n  };\r\n  return parseFloat(value) * (unitMultipliers[unit] || 1);\r\n};\r\n\r\nexport const convertNumberToDecimalLetterUnit = (number) => {\r\n  const units = ['', 'K', 'M', 'B', 'T', 'Q'];\r\n  let unitIndex = 0;\r\n  \r\n  while (number >= 1000 && unitIndex < units.length - 1) {\r\n    number /= 1000;\r\n    unitIndex++;\r\n  }\r\n  \r\n  // Determine the number of decimal places\r\n  let decimalPlaces = 2;\r\n  if (number >= 100) decimalPlaces = 1;\r\n  if (number >= 1000) decimalPlaces = 0;\r\n  \r\n  // Format the number\r\n  const formattedNumber = number.toFixed(decimalPlaces);\r\n  \r\n  // Remove trailing zeros after the decimal point\r\n  const trimmedNumber = formattedNumber.replace(/\\.?0+$/, '');\r\n  \r\n  return `${trimmedNumber} ${units[unitIndex]}`.trim();\r\n};\r\n\r\nexport const calculateScienceTime = (values, units) => {\r\n\r\n\r\n  const [sciencePerSec, scienceSaved, scienceNeeded] = values.map((value, index) => \r\n    convertInputUsingLetterUnitToNumber(value, units[index])\r\n  );\r\n\r\n  if (sciencePerSec <= 0 || isNaN(scienceSaved) || isNaN(scienceNeeded)) {\r\n    return { error: \"Invalid input. Please check your values.\" };\r\n  }\r\n\r\n  const timeInTicks = Math.max(0, Math.round((scienceNeeded - scienceSaved) / sciencePerSec));\r\n  \r\n  const timespan = formatTicksToDayHourMinuteSec(timeInTicks)\r\n\r\n  return {\r\n    ticks: timeInTicks,\r\n    timespan: timespan\r\n  };\r\n};\r\n\r\nconst getEVCostFromGPCount = (gpCount) => {\r\n\treturn parseFloat(Math.pow((gpCount*400), 3));\r\n};\r\n\r\nexport const calculateGPEfficiency = (currentGP, setupTime, evPerSecond, evUnit) => {\r\n  const currentGPFloat = parseFloat(currentGP);\r\n  const setupTimeSeconds = parseFloat(setupTime) * 3600; // Convert hours to seconds\r\n  const evPerSecondValue = convertInputUsingLetterUnitToNumber(evPerSecond, evUnit);\r\n\r\n  const currentGPCountEVCost = getEVCostFromGPCount(currentGPFloat);\r\n  const timeToCurrentGPCountSeconds = currentGPCountEVCost / evPerSecondValue;\r\n  const adjustedRunTimeSeconds = setupTimeSeconds - timeToCurrentGPCountSeconds;\r\n\r\n  const lineChart1Data = [];\r\n  const lineChart2Data = [];\r\n\r\n  for (let x = 0; x <= 3000; x += 1) {\r\n    const futureGPCount = currentGPFloat + x;\r\n    const costDifferenceEVCurrentToFuture = getEVCostFromGPCount(futureGPCount) - currentGPCountEVCost;\r\n    const timeDifferenceCurrentToFutureSeconds = costDifferenceEVCurrentToFuture / evPerSecondValue;\r\n    const projectedTotalRunTimeSecond = adjustedRunTimeSeconds + timeDifferenceCurrentToFutureSeconds;\r\n    const projectedTotalRunTimeHours = projectedTotalRunTimeSecond / 3600;\r\n    const futureGPperHour = futureGPCount / projectedTotalRunTimeHours;\r\n    lineChart1Data.push({ x: futureGPCount, y: futureGPperHour });\r\n    lineChart2Data.push({ x: futureGPCount, y: projectedTotalRunTimeHours });\r\n  }\r\n\r\n  return {\r\n    lineChart1Data,\r\n    lineChart2Data,\r\n    inputValues: { currentGP, setupTime, evPerSecond, evUnit },\r\n  };\r\n};\r\n\r\nexport const getEraData = (sciencePerSec) => {\r\n  return eraData.slice(0, 20).map(era => {\r\n    const timeToReach = Math.ceil(era.EraCost / sciencePerSec);\r\n    return {\r\n      ...era,\r\n      TimeToReach: formatTicksToDayHourMinuteSec(timeToReach)\r\n    };\r\n  });\r\n};\r\n\r\nconst formatTicksToDayHourMinuteSec = (seconds) => {\r\n  const days = Math.floor(seconds / 86400);\r\n  const hours = Math.floor((seconds % 86400) / 3600);\r\n  const minutes = Math.floor((seconds % 3600) / 60);\r\n  const remainingSeconds = seconds % 60;\r\n\r\n  const parts = [];\r\n\r\n  if (days > 0) parts.push(`${days}d`);\r\n  if (hours > 0) parts.push(`${hours}h`);\r\n  if (minutes > 0) parts.push(`${minutes}m`);\r\n  if (remainingSeconds > 0 || parts.length === 0) parts.push(`${remainingSeconds}s`);\r\n\r\n  return parts.join(' ');\r\n};\r\n\r\nexport const eFormatTime = (hours) => {\r\n  const days = Math.floor(hours / 24);\r\n  const remainingHours = hours % 24;\r\n  return `${days}d ${remainingHours.toFixed(2)}h`;\r\n};\r\n\r\nexport const buildGraph = (buildings) => {\r\n  const graph = {};\r\n\r\n  // Initialize nodes\r\n  for (const building of buildings) {\r\n    graph[building.id] = { building, inEdges: [], outEdges: [] };\r\n  }\r\n\r\n  // Connect nodes\r\n  for (const [id, node] of Object.entries(graph)) {\r\n    for (const output in node.building.output) {\r\n      for (const [otherId, otherNode] of Object.entries(graph)) {\r\n        if (otherId !== id && output in otherNode.building.input) {\r\n          node.outEdges.push(otherId);\r\n          otherNode.inEdges.push(id);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return graph;\r\n};\r\n\r\nexport const calculateResourceFlow = (graph, startNodeId, multipliers, globalBuff) => {\r\n  const flow = { ratios: {}, relevantBuildings: new Set(), requiredAmounts: {} };\r\n  const visited = new Set();\r\n\r\n  const dfs = (nodeId, requiredAmount = 1) => {\r\n    flow.relevantBuildings.add(nodeId);\r\n    \r\n    const node = graph[nodeId];\r\n    const nodeMultiplier = (multipliers[nodeId] || 1) + globalBuff;\r\n    \r\n    // Initialize or update the required amount for this node\r\n    flow.requiredAmounts[nodeId] = (flow.requiredAmounts[nodeId] || 0) + requiredAmount;\r\n    \r\n    // Only process inputs if we haven't visited this node or if we need more of its output\r\n    if (!visited.has(nodeId) || flow.requiredAmounts[nodeId] > flow.ratios[nodeId]) {\r\n      visited.add(nodeId);\r\n      \r\n      // Calculate the ratio for this node\r\n      const outputAmount = Object.values(node.building.output)[0] * nodeMultiplier;\r\n      flow.ratios[nodeId] = flow.requiredAmounts[nodeId] / outputAmount;\r\n\r\n      // Recurse through input edges\r\n      for (const [inputResource, inputAmount] of Object.entries(node.building.input)) {\r\n        for (const inNodeId of node.inEdges) {\r\n          const inNode = graph[inNodeId];\r\n          if (inputResource in inNode.building.output) {\r\n            const requiredInputAmount = inputAmount * flow.ratios[nodeId];\r\n            dfs(inNodeId, requiredInputAmount);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  dfs(startNodeId);\r\n  return flow;\r\n};\r\n\r\nexport const processChainData = (flow, graph) => {\r\n  return Array.from(flow.relevantBuildings).map(buildingId => {\r\n    const building = graph[buildingId].building;\r\n    return {\r\n      id: buildingId,\r\n      name: building.name,\r\n      input: formatResourceObject(building.input),\r\n      output: formatResourceObject(building.output),\r\n      ratio: flow.ratios[buildingId],\r\n      requiredAmount: flow.requiredAmounts[buildingId]\r\n    };\r\n  }).sort((a, b) => a.name.localeCompare(b.name));\r\n};\r\n\r\nconst formatResourceObject = (obj) => {\r\n  return Object.entries(obj)\r\n    .map(([key, value]) => `${key}: ${value}`)\r\n    .join('\\n');\r\n};"],"names":["_ref","title","description","_jsxs","Box","sx","mb","children","_jsx","Typography","variant","gutterBottom","fontStyle","color","borderLeft","borderColor","pl","tooltip","props","style","display","alignItems","TextField","Tooltip","arrow","placement","IconButton","size","marginLeft","HelpOutlineIcon","fontSize","IdleEraTime","sciencePerSec","setSciencePerSec","useState","eraData","setEraData","useEffect","isNaN","parseFloat","data","getEraData","Paper","elevation","p","maxWidth","mx","PageHeader","bgcolor","borderRadius","Grid","item","xs","sm","TooltipTextField","label","type","value","onChange","e","target","fullWidth","inputProps","step","length","TableContainer","component","Table","TableHead","TableRow","TableCell","TableBody","map","row","Era","EraTitle","EraCost","TimeToReach","convertInputUsingLetterUnitToNumber","unit","calculateScienceTime","values","units","scienceSaved","scienceNeeded","index","error","timeInTicks","Math","max","round","ticks","timespan","formatTicksToDayHourMinuteSec","getEVCostFromGPCount","gpCount","pow","calculateGPEfficiency","currentGP","setupTime","evPerSecond","evUnit","currentGPFloat","setupTimeSeconds","evPerSecondValue","currentGPCountEVCost","adjustedRunTimeSeconds","lineChart1Data","lineChart2Data","x","futureGPCount","projectedTotalRunTimeHours","futureGPperHour","push","y","inputValues","slice","era","timeToReach","ceil","seconds","days","floor","hours","minutes","remainingSeconds","parts","concat","join"],"sourceRoot":""}